<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Arch:  Cache Coherence - Yizhou Shan's Home Page</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <link href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Arch:  Cache Coherence";
    var mkdocs_page_input_path = "notes/cache_coherence.md";
    var mkdocs_page_url = "/notes/cache_coherence/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Yizhou Shan's Home Page</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	  
          
		  
  <ul class="" href="../..">
    <li class="toctree-l1">
  <a class="" href="../..">Home</a>
  </li></ul>
          
		  
  <ul class="" href="../../misc/essential/">
    <li class="toctree-l1">
  <a class="" href="../../misc/essential/">Essential</a>
  </li></ul>
          
		  
  <ul class="" href="../../misc/cheatsheet/">
    <li class="toctree-l1">
  <a class="" href="../../misc/cheatsheet/">Cheatsheet</a>
  </li></ul>
          
		  
  <p class="caption">Notes</p>
  <ul class="current">
          <li class="toctree-l1">
            
  <a class="" href="../rmap/">Linux: Reverse Mmap</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../trace/">Linux: Tracing</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../cgroup-swap/">Linux: Cgroup and Swap</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../userfaultfd/">Linux: Userfaultfd</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../xperf/">Linux: User/kern Cross Perf</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../kvm-basic/">KVM:   Basics</a>
        </li>
          <li class="toctree-l1 current">
            
  <a class="current" href="./">Arch:  Cache Coherence</a>
  <ul class="subnav">
      
  <li class="toctree-l2 current">
  
    <a class="current"  href="#cache-coherence">Cache Coherence</a>
  
  
    <ul class="">
    
        <li class="toctree-l3 toc-item" >
          <a class="toctree-l3" href="#summary-and-thoughs">Summary and Thoughs</a>
        </li>
    
        <li class="toctree-l3 toc-item" >
          <a class="toctree-l3" href="#references">References</a>
        </li>
    
        <li class="toctree-l3 toc-item" >
          <a class="toctree-l3" href="#misc-small-facts">Misc Small Facts</a>
        </li>
    
    </ul>
  
  </li>

  </ul>
        </li>
  </ul>

          
		  
  <p class="caption">LegoOS</p>
  <ul class="">
          <li class="toctree-l1">
            
  <a class="" href="/lego/log/TODO">Log</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/kernel/kconfig">Kernel</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/syscall/facts">Syscall</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/pcache/config">Pcache</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/driver/pci">Driver</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/paper/nmp">Paper</a>
        </li>
  </ul>

          
		  
  <p class="caption">FPGA</p>
  <ul class="">
          <li class="toctree-l1">
            
  <a class="" href="../../fpga/hls_axi/">HLS: Usage of AXI-Stream</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../fpga/hls_axi/">HLS: High-performance AXI-MM</a>
        </li>
  </ul>

          
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Yizhou Shan's Home Page</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Notes &raquo;</li>
        
      
    
    <li>Arch:  Cache Coherence</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="cache-coherence">Cache Coherence</h1>
<p>A general collection of resources on cache coherence.
I started this when I was having a hard time optimizing lock delegation.
This note is not about acadamic new ideas, but rather for
a concrete understanding of current cache coherence implementations.</p>
<h2 id="summary-and-thoughs">Summary and Thoughs</h2>
<ul>
<li>The textbooks tough us the basic concept of MESI. And realizations
  like snoop and directory. But what usually missing is the implementation
  details when it comes to: 1) conflicts, 2) no single shared bus.</li>
<li>Modern processors have Network-on-Chip (NoC). Cores, cache slices,
  and memory controllers are connected via an on-chip network.
  The model is no different from a datacenter cluster connected by real network.</li>
<li>Cache requests generated by MESI protocols should appear <em>atomic</em> to cores.
  Given the distributed nature of all resources, those cache requests
  will have to be implemented like <strong>distributed transactions</strong>.</li>
<li>For example, the MESIF is the cache coherence protocol used by Intel.
  When a read is made to an invalid line, the corresponding cache
  will perform a <em>cache read transaction</em> to read the data from
  either other caches or memory. This transaction consists multiple
  steps such as: send requests, collect responses, send ACKs.</li>
<li>Those transactions will conflict if multiple reads and writes
  happen at the same time. Someone has to resolve it.
  It can be resolved by different cache controllers, or by a single
  serialization point like home agent.</li>
<li>Just like you can have many ways to implement transactions
  for distributed systems, there are also many ways to do
  cache coherence transactions. And there are many.</li>
<li>Atomic Read-Modify-Write (RMW) instructions will make cache coherence
  implementations even more complex. Those instructions include
  <code class="codehilite">read-and-inc</code>, <code class="codehilite">test-and-set</code>, and <code class="codehilite">lock;</code>-prefixed.
  I think, there will some &ldquo;lock the bus&rdquo;, or &ldquo;locked state&rdquo; at the
  home agent per cache line. Having atomic RMW instructions
  will add more complexity to the overall transaction desgin.</li>
<li>While reading Intel related cache coherence diagrams/transactions,
  you might find many different descriptions. Don&rsquo;t panic. They are
  just different implementations proposed by Intel. Different
  implementations will have different trade-offs and performance,
  you can check <a href="https://frankdenneman.nl/2016/07/11/numa-deep-dive-part-3-cache-coherency/">Frank&rsquo;s post</a>
  for more details.</li>
<li>Directory-based cache coherence procotol and implementation will
  be the future for multicore machines. Because it incurs much less
  coherence traffic than snoop-based ones, thus more scalable.
  The trend is confirmed by recent Intel UPI directory-based approach.
  Related readings:
  [1]: <a href="http://www.cis.upenn.edu/acg/papers/cacm12_why_coherence.pdf">Why On-Chip Cache Coherence Is Here to Stay</a>
  [2]: <a href="https://www.realworldtech.com/qpi-evolved/3/">QPI 1.1 Invovled</a></li>
</ul>
<p>Left questions:
- Do cache coherence implementations ensure <strong>fairness</strong> among cores?</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.455.4198&amp;rep=rep1&amp;type=pdf">The Architecture of the Nehalem Processor and Nehalem-EP SMP Platforms</a>, chapter 5.2 Cache-Coherence Protocol for Multi-Processors.<ul>
<li>This serves an entry-level description about how x86 MESIF works.</li>
<li>Also this is a very good paper about general x86 microarchitectures.</li>
</ul>
</li>
<li><a href="https://frankdenneman.nl/2016/07/11/numa-deep-dive-part-3-cache-coherency/">NUMA Deep Dive Part 3: Cache Coherency</a><ul>
<li>By far the BEST blog I&rsquo;ve seen on the topic of Intel snoop models! Frank&rsquo;s other articles are also amazing.</li>
<li>Intel is using MESIF cache coherence protocol, but it has multiple cache coherence implementations.
  The first one is <code class="codehilite">Source Snoop</code> (or <code class="codehilite">Early Snoop</code>), which is more like a traditional snoop-based
  cache coherence implementation. Upon miss, the caching agent will broadcast to other agents.
  The second one is <code class="codehilite">Home Snoop</code>, which is more like a directory-based cache coherence implementation.
  Upon miss, the caching agent will contact home agent, and then the home agent will send requests
  to other caching agents who have the requested cache line.
  There are other implementations like Cluster-on-Die.
  Intel UPI gets rid of all this complexity, it is only using directory-based, in the hope to reduce
  cache coherence traffic, which make sense.</li>
<li>Related: <a href="https://software.intel.com/en-us/articles/intel-xeon-processor-e5-2600-v4-product-family-technical-overview">Broadwell EP Snoop Models</a></li>
<li>Related: <a href="https://software.intel.com/en-us/articles/intel-xeon-processor-scalable-family-technical-overview">Skylay UPI</a></li>
</ul>
</li>
<li><a href="https://researchspace.auckland.ac.nz/bitstream/handle/2292/11594/MESIF-2009.pdf?sequence=6">MESIF: A Two-Hop Cache Coherency Protocol for Point-to-Point Interconnects (2009)</a><ul>
<li>This paper has the most extensive description of the MESIF protocol implementation.
  It has many <strong>timing diagrams</strong> than describe how cache requests actually proceed.
  Those diagrams can help us understand what is needed to finish a cache request.</li>
<li>Their <a href="https://parlab.eecs.berkeley.edu/sites/all/parlab/files/20091029-goodman-ssccp.pdf">slides</a>
  has more timing diagrams.</li>
<li>But do note: the implementation described by this paper is different from
  what <a href="https://www.intel.ca/content/dam/doc/white-paper/quick-path-interconnect-introduction-paper.pdf">Intel QPI</a>
  has in products. The difference is discussed at chapter 4. MESIF and QPI, namely,
  other caching agents will send responses to Home agent rather than to requesting agent.
  QPI relies on Home agent to solve conflict.</li>
<li>Also note: this is just one of the possible implementations to realize MESIF protocol.
  There could be many other ways, e.g., QPI source snooping, QPI home snooping.
  But all of them share the essential and general concepts and ideas.</li>
</ul>
</li>
<li><a href="http://www.cis.upenn.edu/acg/papers/cacm12_why_coherence.pdf">Why On-Chip Cache Coherence Is Here to Stay</a><ul>
<li>This paper discusses why cache coherence can scale. A nice read.</li>
<li>R1: Coherence’s interconnection network traffic per miss scales
      when precisely tracking sharers. (Okay increased directory bits,
  what about those storage cost? See R2).</li>
<li>R2: Hierarchy combined with inclusion enables efficient scaling
      of the storage cost for exact encoding of sharers.</li>
<li>R3: private evictions should send explict messages to shared cache
      to enable precise tracking. Thus the recall (<em>back invalidation</em>) traffic can be
  reduced when shared cache is evicting (assume inclusion cache).</li>
<li>R4: Latencies of cache request can be amotized. </li>
</ul>
</li>
<li><a href="https://www.elsevier.com/books-and-journals/book-companion/9780128119051">Appendix I: Large-Scale Multiprocessors and Scientific Applications</a>,
  chapter 7 Implementing Cache Coherence.<ul>
<li>This is probably some most insightful discussion about real implementation of cache coherence.
  With the distributed nature and Network-on-Chip, implementing cache coherence in modern
  processors is no different than implementing a distributed transaction protocol.</li>
<li>Cache activities like read miss or write miss have multi-step operations, but they
  need to appear as &ldquo;atomic&rdquo; to users. Put in another way, misses are like transactions,
  they have multiple steps but they must be atomic. They can be retried.</li>
<li>Having directory for cache coherence will make implementation easier. Because
  the place (e.g., L3) where directory resides can serve as the serialization point.
  They can solve write races.</li>
<li><code class="codehilite">Home directory controller</code> and <code class="codehilite">cache controller</code> will exchange messages like a set of distributed machines.
  In fact, with NoC, they are actually distributed system.</li>
</ul>
</li>
<li><a href="https://www.intel.ca/content/dam/doc/white-paper/quick-path-interconnect-introduction-paper.pdf">An Introduction to the Intel® QuickPath Interconnect</a>,
  page 15 MESIF.<ul>
<li>It explains the <code class="codehilite">Home Snoop</code> and <code class="codehilite">Source Snoop</code> used by Intel.</li>
<li>Based on their explanation, it seems both <code class="codehilite">Home Snoop</code> and <code class="codehilite">Source Snoop</code> are using a combination of
    snoop and directory. The Processor#4 (pg 17 and 18) maintains the directory.</li>
<li>And this is a perfect demonstration of the details described in <a href="https://www.elsevier.com/books-and-journals/book-companion/9780128119051">Appendix I: Large-Scale Multiprocessors and Scientific Applications</a>.</li>
<li>Related patent: <a href="https://patents.google.com/patent/US20150081977">Extending a cache coherency snoop broadcast protocol with directory information</a></li>
</ul>
</li>
<li>AMD HyperTransport Assit for Cache Coherence<ul>
<li><a href="https://www.hotchips.org/wp-content/uploads/hc_archives/hc14/3_Tue/28_AMD_Hammer_MP_HC_v8.pdf">Slide</a></li>
<li><a href="http://www.hotchips.org/wp-content/uploads/hc_archives/hc21/2_mon/HC21.24.100.ServerSystemsI-Epub/HC21.24.110.Conway-AMD-Magny-Cours.pdf">Slide</a></li>
</ul>
</li>
</ul>
<h2 id="misc-small-facts">Misc Small Facts</h2>
<ul>
<li>Intel Caching Agent (Cbox) is per core (or per LLC slice). Intel Home Agent is per memory controller.<ul>
<li>Starting from Intel UPI, Caching Agent and Home Agent are combined as CHA.</li>
</ul>
</li>
<li>A good <a href="https://www.realworldtech.com/qpi-evolved/3/">discussion</a> about why QPI gradually drop <code class="codehilite">Source Snoop</code> and solely use <code class="codehilite">Home Snoop</code>.<ul>
<li>The motivation is scalability. It turns out the new UPI only supports directory-based protocol.</li>
<li>This makes sense because 1) inter socket bandwidth is precious, 2) snoop will consume a lot bandwidth.</li>
</ul>
</li>
<li>Intel UPI is using directory-based home snoop coherency protocol<ul>
<li><a href="https://software.intel.com/en-us/articles/intel-xeon-processor-scalable-family-technical-overview">Intel® Xeon® Processor Scalable Family Technical Overview</a></li>
</ul>
</li>
<li>To provide sufficient bandwidth, shared caches are typically interleaved
  by addresses with banks physically distibuted across the chip.</li>
</ul>
<p>&ndash;<br />
Yizhou Shan<br />
Created: Jun 28, 2019<br />
Last Updated: Jun 29, 2019</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../lego/log/TODO/" class="btn btn-neutral float-right" title="TODO">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../kvm-basic/" class="btn btn-neutral" title="KVM:   Basics"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../kvm-basic/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../lego/log/TODO/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/require.js"></script>
      <script src="../../search/search.js"></script>

</body>
</html>
