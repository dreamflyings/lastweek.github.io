<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Yizhou Shan">
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>fork() - Yizhou Shan's Home Page</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <link href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "fork()";
    var mkdocs_page_input_path = "lego/syscall/fork.md";
    var mkdocs_page_url = "/lego/syscall/fork/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js"></script>
  <script src="../../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../../js/highlight.pack.js"></script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-143772066-1', 'auto');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> Yizhou Shan's Home Page</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	  
          
		  
  <ul class="" href="../../..">
    <li class="toctree-l1">
  <a class="" href="../../..">Home</a>
  </li></ul>
          
		  
  <p class="caption">Notes</p>
  <ul class="">
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/paper_fpga/">FPGA Papers</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/cache_coherence/">Cache Coherence</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/benchmark/">Benchmarks</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/paper_perf_shadows/">Perf Shadows</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/proc/">[Linux] Special Files</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/rmap/">[Linux] Reverse Mmap (rmap)</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/trace/">[Linux] Trace/Profile</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/cgroup-swap/">[Linux] Cgroup and Swap</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/userfaultfd/">[Linux] Userfaultfd</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/xperf/">[Linux] User/kern Cross Perf</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../notes/kvm-basic/">[Linux] KVM</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../misc/essential/">Essential</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../misc/cheatsheet/">Cheatsheet</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/general_log/0919">Log</a>
        </li>
  </ul>

          
		  
  <p class="caption">FPGA</p>
  <ul class="">
          <li class="toctree-l1">
            
  <a class="" href="../../../fpga/hls_axi/">HLS: Usage of AXI-Stream</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../fpga/hls_axi/">HLS: High-performance AXI-MM</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="../../../fpga/vivado_tricks/">Vivado Tricks</a>
        </li>
  </ul>

          
		  
  <p class="caption">LegoOS-Dev</p>
  <ul class="current">
          <li class="toctree-l1">
            
  <a class="" href="/lego/log/TODO">Log</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/kernel/kconfig">Kernel</a>
        </li>
          <li class="toctree-l1 current">
            
  <a class="current" href="/lego/syscall/facts">Syscall</a>
  <ul class="subnav">
        <li class="toctree-l2 1">
            
  <a class="" href="../facts/">Facts</a>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../../kernel/profile_strace/">strace</a>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../compat/">compat</a>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../msync/">msync()</a>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../mremap/">mremap()</a>
        </li>
        <li class="toctree-l2 current 1">
            
  <a class="current" href="./">fork()</a>
  <ul class="subnav">
      
  <li class="toctree-l2 current">
  
  
    <ul class="">
    
        <li class="toctree-l3 toc-item" >
          <a class="toctree-l3" href="#memory-manager">Memory Manager</a>
        </li>
    
        <li class="toctree-l3 toc-item" >
          <a class="toctree-l3" href="#processor-manager">Processor Manager</a>
        </li>
    
    </ul>
  
  </li>

  </ul>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../getrusage/">getrusage()</a>
        </li>
        <li class="toctree-l2 1">
            
  <a class="" href="../wait_and_exit/">wait4 and exit()</a>
        </li>
  </ul>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/pcache/config">Pcache</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/driver/pci">Driver</a>
        </li>
          <li class="toctree-l1">
            
  <a class="" href="/lego/paper/nmp">Paper</a>
        </li>
  </ul>

          
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">Yizhou Shan's Home Page</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>LegoOS-Dev &raquo;</li>
        
      
        
          <li>Syscall &raquo;</li>
        
      
    
    <li>fork()</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="fork">fork()<a class="headerlink" href="#fork" title="Permanent link">&para;</a></h1>
<h2 id="memory-manager">Memory Manager<a class="headerlink" href="#memory-manager" title="Permanent link">&para;</a></h2>
<p>We need to duplicate the address space in the memory manager side. Follow the traditional <code class="codehilite">fork()</code> semantic, both the existing and newly created address space will be write-protected.</p>
<p>Since we have the flexibility to implement any VM organization, we should be careful while duplicating the address space. Currently, we are using page-based VM, thus the duplicating is basically creating a new <code class="codehilite">pgd</code> and copy existing pgtables, and further downgrade permission to read-only. This is now performed by <code class="codehilite">lego_copy_page_range()</code>.</p>
<p>The final write-protect is performed by <code class="codehilite">lego_copy_one_pte()</code>:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lego_copy_one_pte</span><span class="p">(..)</span>
<span class="p">{</span>
    <span class="p">..</span>
    <span class="cm">/*</span>
<span class="cm">     * If it&#39;s a COW mapping, write protect it both</span>
<span class="cm">     * in the parent and the child</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ptep_set_wrprotect</span><span class="p">(</span><span class="n">src_pte</span><span class="p">);</span>   
        <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>      
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<h3 id="duplicate-vm-free-pool">Duplicate VM Free Pool<a class="headerlink" href="#duplicate-vm-free-pool" title="Permanent link">&para;</a></h3>
<p><mark class="critic">TODO</mark> Yutong</p>
<h2 id="processor-manager">Processor Manager<a class="headerlink" href="#processor-manager" title="Permanent link">&para;</a></h2>
<p>Boring implementation details in the processor manager side.</p>
<h3 id="entry-points">Entry Points<a class="headerlink" href="#entry-points" title="Permanent link">&para;</a></h3>
<ul>
<li><code class="codehilite">fork()</code></li>
<li><code class="codehilite">vfork()</code></li>
<li><code class="codehilite">clone()</code></li>
<li><code class="codehilite">kernel_thread()</code></li>
</ul>
<p>All of them land on <code class="codehilite">do_fork()</code>, which is Lego&rsquo;s main fork function.</p>
<h3 id="do_fork">do_fork()<a class="headerlink" href="#do_fork" title="Permanent link">&para;</a></h3>
<p>There are mainly three parts within <code class="codehilite">do_fork()</code>: <code class="codehilite">1)</code> <code class="codehilite">copy_process()</code>, which duplicates a new task based on <code class="codehilite">current</code>, including allocate new kernel stack, new task_struct, increase mm reference counter, etc. <code class="codehilite">2)</code> If we are creating a new process, then tell global monitor or memory manager to let them update bookkeeping and create corresponding data structures. <code class="codehilite">3)</code> <code class="codehilite">wake_up_new_task()</code>, which gives away the newly created task to local scheduler.</p>
<h4 id="copy_process">copy_process()<a class="headerlink" href="#copy_process" title="Permanent link">&para;</a></h4>
<p>The routine is kind of boring. It do a lot dirty work to copy information from calling thread to new thread. The most important data structures of course are <code class="codehilite">task_struct</code>, <code class="codehilite">mm_sturct</code>, <code class="codehilite">sighand</code>, and so on. This section only talks about few of them, and leave others to readers who are interested.</p>
<h5 id="sanity-checking">Sanity Checking<a class="headerlink" href="#sanity-checking" title="Permanent link">&para;</a></h5>
<p>Mainly check if <code class="codehilite">clone_flags</code> are passed properly. For example, if user is creating a new thread, that implies certain data structures are shared, cause new thread belongs to the same process with the calling thread. If <code class="codehilite">CLONE_THREAD</code> is passed, then <code class="codehilite">CLONE_SIGHAND</code>, <code class="codehilite">CLONE_VM</code>, and so on must be set as well.
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    <span class="cm">/*</span>
<span class="cm">     * Thread groups must share signals as well, and detached threads</span>
<span class="cm">     * can only be started up within the thread group.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SIGHAND</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Shared signal handlers imply shared VM. By way of the above,</span>
<span class="cm">     * thread groups also imply shared VM. Blocking this case allows</span>
<span class="cm">     * for various simplifications in other code.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SIGHAND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<h5 id="dup_task_struct">dup_task_struct()<a class="headerlink" href="#dup_task_struct" title="Permanent link">&para;</a></h5>
<p>Two main things: 1) duplicate a new <code class="codehilite">task_struct</code>, 2) duplicate a new kernel stack. x86 is just a weird architecture, the size of <code class="codehilite">task_struct</code> depends on the size of fpu. So the allocation and duplication need to callback to x86-specific code to duplicate the task_struct and fpu info.
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">arch_dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">arch_task_struct_size</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">fpu__copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
The stack duplication is fairly simple, just copy everything from the old stack to new stack. Of course, it needs to setup the <code class="codehilite">thread_info</code> to points to this new thread, so the <code class="codehilite">current</code> macro will work.
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_thread_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">org</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* Duplicate whole stack! */</span>
        <span class="o">*</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">org</span><span class="p">);</span>

        <span class="cm">/* Make the `current&#39; macro work */</span>
        <span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<h5 id="copy_mm">copy_mm()<a class="headerlink" href="#copy_mm" title="Permanent link">&para;</a></h5>
<p>This is where threads within a process will share the virtual address space happens. If we are creating a new process, then this function will create a new <code class="codehilite">mm_struct</code>, and also a new <code class="codehilite">pgd</code>:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * pgd_alloc() will duplicate the identity kernel mapping</span>
<span class="cm"> * but leaves other entries empty:</span>
<span class="cm"> */</span>
<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<h5 id="duplicate-pcache-data">Duplicate pcache data<a class="headerlink" href="#duplicate-pcache-data" title="Permanent link">&para;</a></h5>
<p><mark class="critic">TODO</mark></p>
<details class="danger" open="open"><summary>TODO: hook with pcache</summary><p>We need to duplicate the pcache vm_range array, once Yutong finished the code.</p></details><h5 id="setup_sched_fork">setup_sched_fork()<a class="headerlink" href="#setup_sched_fork" title="Permanent link">&para;</a></h5>
<p>Callback to scheduler to setup this new task. It may reset all scheduler related information. Here we also have a chance to change this task&rsquo;s scheduler class:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">setup_sched_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

        <span class="n">__sched_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_NEW</span><span class="p">;</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">;</span>
                        <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                        <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="p">...</span>
        <span class="p">}</span>    

        <span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
                <span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>    

        <span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">)</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h5 id="allocate-new-pid">Allocate new pid<a class="headerlink" href="#allocate-new-pid" title="Permanent link">&para;</a></h5>
<p>In both Lego and Linux, we don&rsquo;t allocate new pid for a new thread, if that thread is an <code class="codehilite">idle thread</code>. So callers of <code class="codehilite">do_fork</code> needs to pass something to let <code class="codehilite">do_fork</code> know. In Linux, they use <code class="codehilite">struct pid, init_struct_pid</code> to check. In Lego, we introduce an new clone_flag <code class="codehilite">CLONE_IDLE_THREAD</code>. If that flag is set, <code class="codehilite">do_fork()</code> will try to allocate a new pid for the new thread. Otherwise, it will be 0:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cm">/* clone idle thread, whose pid is 0 */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_IDLE_THREAD</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">alloc_pid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_cleanup_thread</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<p>So, only the <code class="codehilite">init_idle()</code> function can pass this <code class="codehilite">CLONE_IDLE_THREAD</code> down. All other usages are wrong and should be reported.</p>
<p>In order to avoid conflict with Linux clone_flag, we define it as:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define CLONE_IDLE_THREAD       0x100000000</span>
</pre></div>
</td></tr></table></p>
<h5 id="settidcleartid">SETTID/CLEARTID<a class="headerlink" href="#settidcleartid" title="Permanent link">&para;</a></h5>
<p>These are some futex related stuff. I will cover these stuff in futex document:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">p</span><span class="o">-&gt;</span><span class="n">set_child_tid</span> <span class="o">=</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_CHILD_SETTID</span><span class="p">)</span> <span class="o">?</span> <span class="nl">child_tidptr</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cm">/*  </span>
<span class="cm"> * Clear TID on mm_release()?</span>
<span class="cm"> */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span> <span class="o">=</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_CHILD_CLEARTID</span><span class="p">)</span> <span class="o">?</span> <span class="nl">child_tidptr</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FUTEX</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">robust_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table></p>
<h5 id="copy_thread_tls">copy_thread_tls()<a class="headerlink" href="#copy_thread_tls" title="Permanent link">&para;</a></h5>
<p>This is the most interesting function. Cover later.</p>
<h4 id="p2m_fork">p2m_fork()<a class="headerlink" href="#p2m_fork" title="Permanent link">&para;</a></h4>
<p>In order to track user activities, we need to know when user are going to create new process. Fork is the best time and the only time we kernel know. So, Lego adds this special hook to tell remote global monitor or memory manager that there is a new process going to be created. Upon receiving this message, remote monitor will update its bookkeeping for this specific user/vNode.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cm">/* Tell remote memory component */</span>
<span class="cp">#ifdef CONFIG_COMP_PROCESSOR</span>
<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_GLOBAL_THREAD</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">p2m_fork</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">clone_flags</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>   
<span class="cp">#endif</span>
</pre></div>
</td></tr></table>

<p>The <code class="codehilite">CLONE_GLOBAL_THREAD</code> should only be set, if the following cases happen:</p>
<ul>
<li>fork()</li>
<li>vfork()</li>
<li>clone(), without <code class="codehilite">CLONE_THREAD</code> being set</li>
</ul>
<p>In order to avoid conflict with Linux clone_flag, we define it as:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define CLONE_GLOBAL_THREAD     0x200000000</span>
</pre></div>
</td></tr></table></p>
<h4 id="wake_up_new_task">wake_up_new_task()<a class="headerlink" href="#wake_up_new_task" title="Permanent link">&para;</a></h4>
<p>The last step of <code class="codehilite">do_fork</code> is waking up the new thread or process, which is performed by <code class="codehilite">wake_up_new_task()</code> function. The first question this function will ask is: <code class="codehilite">which cpu to land?</code> The answer comes from <code class="codehilite">select_task_rq()</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">select_task_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Clearly, this is determined by <code class="codehilite">cpus_allowed</code>, which is the same with its parent at this point. That being said, if the parent is only able to run on one specific CPU, then all its children will end up running on the same CPU when they wake up (they could change their affinity later). This is also the default on Linux: <code class="codehilite">A child created via fork(2) inherits its parent&#39;s CPU affinity mask. The affinity mask is preserved across an execve(2).</code></p>
<p>After landing CPU is selected, following operation is simple: just enqueue this task into landing CPU&rsquo;s runqueue, and we are done:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>
<span class="cm">/* Select a CPU for new thread to run */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
        <span class="cm">/*   </span>
<span class="cm">         * Fork balancing, do it here and not earlier because:</span>
<span class="cm">         *  - cpus_allowed can change in the fork path</span>
<span class="cm">         *  - any previously selected cpu might disappear through hotplug</span>
<span class="cm">         */</span>
        <span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">SD_BALANCE_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif</span>

        <span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>&ndash;<br />
Yizhou Shan<br />
Created: Feb 11, 2018<br />
Last Updated: Feb 27, 2018</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../getrusage/" class="btn btn-neutral float-right" title="getrusage()">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../mremap/" class="btn btn-neutral" title="mremap()"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../mremap/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../getrusage/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/require.js"></script>
      <script src="../../../search/search.js"></script>

</body>
</html>
